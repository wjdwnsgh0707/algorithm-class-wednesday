#===========================================
# Graph 관련 알고리즘
#===========================================
# 1. 깊이 우선 탐색 (DFS) - 인접행렬 기반 재귀 구현



# -------------------------------
# 테스트 코드
# -------------------------------
if __name__ == "__main__":
    # 정점 리스트
    
    # 인접 행렬 
    

    print('DFS(출발: U) : ', end="")
    visited = [False] * len(vtx)   # 방문 여부 리스트 초기화
    DFS(vtx, edge, 0, visited)     # U(인덱스 0)에서 시작


# 2. 너비 우선 탐색 (BFS) - 인접 리스트 사용
 


# -------------------------------
# 테스트 코드
# -------------------------------
if __name__ == "__main__":
    # 정점 리스트
    
    # 인접 리스트 
    

    print('BFS_AL(출발: U) : ', end="")
    BFS_AL(vtx, alist, 0)  # 시작점 U는 인덱스 0



# 3. DFS를 이용한 신장트리 생성 (인접행렬 방식)



# -------------------------------
# 테스트 코드
# -------------------------------
if __name__ == "__main__":
    # 정점 리스트
    
    # 인접 행렬 
    

    print("ST_DFS_AM : ", end="")
    visited = [False] * len(vtx)
    ST_DFS(vtx, adj, 0, visited)   # U에서 시작


# 4. Prim 알고리즘 (인접행렬 방식)



 

# ---------------------------------------------------
# 테스트 코드
# ---------------------------------------------------
if __name__ == "__main__":
    # 정점 리스트
    vertex = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
    # 인접 가중치 행렬 
    adj = [
        # A   B    C    D    E    F    G
        [ 0,  25, 999, 12, 999, 999, 999],  # A
        [25,   0, 10, 999, 15, 999, 999],   # B
        [999, 10,  0, 999, 999, 16, 999],   # C
        [12, 999, 999, 0, 17, 999, 37],     # D
        [999, 15, 999, 17, 0, 14, 19],      # E
        [999, 999, 16, 999, 14, 0, 42],     # F
        [999, 999, 999, 37, 19, 42, 0]      # G
    ]

    MSTPrim(vertex, adj)

